red1_model <- lmer(
RMS ~ 1 + MoCA_group * PTA_z + cluster +
(1 | subject_id),
data = data_subset,
control = lmerControl(optimizer = "bobyqa")
)
final_model <- red1_model
final_models <- c(final_models, final_model)
}
if (current_model == "acoustic") {
response_name <- "Speech feature (envelope onsets)"
} else if (current_model == "linguistic word") {
response_name <- "Speech feature (word frequency)"
} else if (current_model == "linguistic phone") {
response_name <- "Speech feature (phoneme entropy)"
}
# ----------------------------------------------------------------------
# Draw inferences and create data frame for table
p_values <- summary(final_model)$coefficients[, "Pr(>|t|)"]
conf_intervals <- confint(
final_model,
parm = "beta_",
method = "Wald",
nsim = 5000,
seed = 2025
)
ci_tab <- as.data.frame(cbind(
estimate = fixef(final_model),
conf_intervals,
p_values
))
if (current_model != "segmentation word" && current_model != "segmentation phone") {
new_coeff_names <- c(
"Intercept",
"MoCA group (low)",
"PTA ($z$)",
response_name,
"Cluster (C)",
"Cluster (P)",
"MoCA group (low) * PTA ($z$)"
)
} else {
new_coeff_names <- c(
"Intercept",
"MoCA group (low)",
"PTA ($z$)",
"Cluster (C)",
"Cluster (P)",
"MoCA group (low) * PTA ($z$)"
)
}
rownames(ci_tab) <- new_coeff_names
# Add significance stars
ci_tab$significance <- ifelse(
ci_tab$p_values < 0.001, "***",
ifelse(
ci_tab$p_values < 0.01, "**",
ifelse(
ci_tab$p_values < 0.05, "*",
""
)
)
)
# Apply formatting
ci_tab$estimate <- sapply(ci_tab$estimate, format_and_wrap)
ci_tab$`2.5 %` <- sapply(ci_tab$`2.5 %`, format_and_wrap)
ci_tab$`97.5 %` <- sapply(ci_tab$`97.5 %`, format_and_wrap)
ci_tab$p_values <- sapply(ci_tab$p_values, format_and_wrap)
ci_tab <- rownames_to_column(ci_tab, var = "Coefficient")
# Rename columns for confidence intervals
colnames(ci_tab) <- c("Coefficient", "Estimate", "$LL$", "$UL$", "$p$", "")
ci_tabs <- c(ci_tabs, ci_tab)
}
# ----------------------------------------------------------------------
# Create nice LaTeX table
model_names <- c(
"Acoustic",
"Segmentation word-level",
"Segmentation phoneme-level",
"Linguistic word-level",
"Linguistic phoneme-level"
)
combined_df <- combine_tables(ci_tabs, model_names)
combined_df <- combined_df[, c("Model", setdiff(names(combined_df), "Model"))]
# Rename columns
colnames(combined_df) <- c("Model", "Coefficient", "Estimate", "$LL$", "$UL$", "$p$", "")
# Create xtable object
xtable_cis <- xtable(combined_df)
# Define alignment for columns
align(xtable_cis) <- c("l", "l", "r", "r", "r", "r", "r", "r")
# Save to .tex file
writeLines(
print(
xtable_cis,
add.to.row = list(pos = list(-1),
command = c("\\hline & & & \\multicolumn{2}{c}{95\\% CI} & \\\\ \\cmidrule(r){4-5}\n")),
include.rownames = FALSE,
hline.after = c(0, nrow(combined_df)),  # Add hline after the header row and at the end
sanitize.text.function = sanitize
),
file.path(tables_dir, rms_table_file)
)
library(jsonlite)
library(lme4)
library(lattice)
library(lmerTest)
library(MuMIn)
library(performance)
library(rstudioapi)
library(xtable)
library(emmeans)
library(car)
library(tibble)
library(dplyr)
library(tidyr)
library(ggplot2)
library(xtable)
# Set working directory and load configurations
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
config <- fromJSON("config.json")
source("helpers.R")
dataframes_dir <- config$dataframes_dir
tables_dir <- config$tables_dir
rms_filename <- paste(dataframes_dir, config$rms_filename, sep = "/")
rms_table_file <- config$rms_table_file
channel_cluster_dummy_dict <- config$channel_cluster_dummy_dict
data <- read.csv(rms_filename)
# + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
# # IMPORTANT: Model!
# model_no <- 4
models <- unique(data$model)
# current_model <- models[model_no]
# + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
# ----------------------------------------------------------------------
# Data subset and preparation
# Preparation 1: Add cluster information to data
data$cluster <- sapply(
data$electrode_id,
find_cluster,
cluster_dict = channel_cluster_dummy_dict
)
# Initialize list to store final models
final_models <- list()
ci_tabs <- list()
for (current_model in models) {
# Preparation 2: Subset data
data_subset <- subset(data, model == current_model)
# Preparation 3: Set response order for each model
if (current_model == "acoustic") {
response_order <- c("envelope", "envelope onsets")
} else if (current_model == "segmentation word") {
response_order <- c("word onset")
} else if (current_model == "segmentation phone") {
response_order <- c("phoneme onset")
} else if (current_model == "linguistic word") {
response_order <- c("word surprisal", "word frequency")
} else if (current_model == "linguistic phone") {
response_order <- c("phoneme surprisal", "phoneme entropy")
}
data_subset$response <- factor(data_subset$response, levels = response_order)
if (current_model != "segmentation word" && current_model != "segmentation phone") {
n_responses <- length(unique(data_subset$response))
contrasts(data_subset$response) <- contr.treatment(n_responses)
}
# Preparation 4: MoCA_group
n_groups <- length(unique(data_subset$MoCA_group))
data_subset$MoCA_group <- factor(data_subset$MoCA_group, levels = c("normal", "low"))
contrasts(data_subset$MoCA_group) <- contr.treatment(n_groups)
# Preparation 5: Subject ID
data_subset$subject_id <- factor(data_subset$subject_id)
# Preparation 5: z-score continuous variables
data_subset$PTA_z <- scale(data_subset$PTA_dB)
# Preparation 6: Cluster
data_subset$cluster <- factor(data_subset$cluster, levels = c("F", "C", "P"))
contrasts(data_subset$cluster) <- contr.treatment(3)
# Check what contrasts look like
data_subset$response
data_subset$MoCA_group
# Check factor variable
data_subset$subject_id
# Check z-scored continuous variables
data_subset$PTA_z
# ----------------------------------------------------------------------
# Define fixed effects structure
# (I only include random intercepts in random effects structure)
# Segmentation models have one response variable only.
if (current_model != "segmentation word" && current_model != "segmentation phone") {
max_model <- lmer(
RMS ~ 1 + MoCA_group * PTA_z * response * cluster +
(1 | subject_id),
data = data_subset,
control = lmerControl(optimizer = "bobyqa")
)
red1_model <- lmer(
RMS ~ 1 + MoCA_group * PTA_z * response + cluster +
(1 | subject_id),
data = data_subset,
control = lmerControl(optimizer = "bobyqa")
)
red2_model <- lmer(
RMS ~ 1 + MoCA_group * PTA_z + response + cluster +
(1 | subject_id),
data = data_subset,
control = lmerControl(optimizer = "bobyqa")
)
final_model <- red2_model
final_models <- c(final_models, final_model)
} else {
max_model <- lmer(
RMS ~ 1 + MoCA_group * PTA_z * cluster +
(1 | subject_id),
data = data_subset,
control = lmerControl(optimizer = "bobyqa")
)
red1_model <- lmer(
RMS ~ 1 + MoCA_group * PTA_z + cluster +
(1 | subject_id),
data = data_subset,
control = lmerControl(optimizer = "bobyqa")
)
final_model <- red1_model
final_models <- c(final_models, final_model)
}
if (current_model == "acoustic") {
response_name <- "Speech feature (envelope onsets)"
} else if (current_model == "linguistic word") {
response_name <- "Speech feature (word frequency)"
} else if (current_model == "linguistic phone") {
response_name <- "Speech feature (phoneme entropy)"
}
# ----------------------------------------------------------------------
# Draw inferences and create data frame for table
p_values <- summary(final_model)$coefficients[, "Pr(>|t|)"]
conf_intervals <- confint(
final_model,
parm = "beta_",
method = "Wald",
nsim = 5000,
seed = 2025
)
ci_tab <- as.data.frame(cbind(
estimate = fixef(final_model),
conf_intervals,
p_values
))
if (current_model != "segmentation word" && current_model != "segmentation phone") {
new_coeff_names <- c(
"Intercept",
"MoCA group (low)",
"PTA ($z$)",
response_name,
"Cluster (C)",
"Cluster (P)",
"MoCA group (low) * PTA ($z$)"
)
} else {
new_coeff_names <- c(
"Intercept",
"MoCA group (low)",
"PTA ($z$)",
"Cluster (C)",
"Cluster (P)",
"MoCA group (low) * PTA ($z$)"
)
}
rownames(ci_tab) <- new_coeff_names
# Add significance stars
ci_tab$significance <- ifelse(
ci_tab$p_values < 0.001, "***",
ifelse(
ci_tab$p_values < 0.01, "**",
ifelse(
ci_tab$p_values < 0.05, "*",
""
)
)
)
# Apply formatting
ci_tab$estimate <- sapply(ci_tab$estimate, format_and_wrap)
ci_tab$`2.5 %` <- sapply(ci_tab$`2.5 %`, format_and_wrap)
ci_tab$`97.5 %` <- sapply(ci_tab$`97.5 %`, format_and_wrap)
ci_tab$p_values <- sapply(ci_tab$p_values, format_and_wrap)
ci_tab <- rownames_to_column(ci_tab, var = "Coefficient")
# Rename columns for confidence intervals
colnames(ci_tab) <- c("Coefficient", "Estimate", "$LL$", "$UL$", "$p$", "")
ci_tabs <- c(ci_tabs, ci_tab)
}
# ----------------------------------------------------------------------
# Create nice LaTeX table
model_names <- c(
"Acoustic",
"Segmentation word-level",
"Segmentation phoneme-level",
"Linguistic word-level",
"Linguistic phoneme-level"
)
combined_df <- combine_tables(ci_tabs, model_names)
combined_df <- combined_df[, c("Model", setdiff(names(combined_df), "Model"))]
# Rename columns
colnames(combined_df) <- c("Model", "Coefficient", "Estimate", "$LL$", "$UL$", "$p$", "")
# Create xtable object
xtable_cis <- xtable(combined_df, caption = "Caption")
# Define alignment for columns
align(xtable_cis) <- c("l", "l", "r", "r", "r", "r", "r", "r")
# Save to .tex file
writeLines(
print(
xtable_cis,
add.to.row = list(pos = list(-1),
command = c("\\hline & & & \\multicolumn{2}{c}{95\\% CI} & \\\\ \\cmidrule(r){4-5}\n")),
include.rownames = FALSE,
hline.after = c(0, nrow(combined_df)),  # Add hline after the header row and at the end
sanitize.text.function = sanitize
),
file.path(tables_dir, rms_table_file)
)
library(jsonlite)
library(lme4)
library(lattice)
library(lmerTest)
library(MuMIn)
library(performance)
library(rstudioapi)
library(sjPlot)
library(jsonlite)
library(lme4)
library(lattice)
library(lmerTest)
library(MuMIn)
library(performance)
library(rstudioapi)
library(sjPlot)
library(jsonlite)
library(lme4)
library(lattice)
library(lmerTest)
library(MuMIn)
library(performance)
library(rstudioapi)
library(xtable)
library(emmeans)
library(car)
library(tibble)
library(dplyr)
library(ggplot2)
# Set working directory and load configurations
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
config <- fromJSON("config.json")
source("helpers.R")
dataframes_dir <- config$dataframes_dir
tables_dir <- config$tables_dir
scores_filename <- paste(dataframes_dir, config$scores_filename, sep = "/")
scores_table_file <- config$scores_table_file
data <- read.csv(scores_filename)
# ----------------------------------------------------------------------
# Data preparation
# Preparation 1: Model to factor then sum coding
n_models <- length(unique(data$model))
model_order <- names(config$models_dict)
data$model <- factor(data$model, levels = model_order)
contrasts(data$model) <- contr.sum(n_models)
# Preparation 2: MoCA_group
n_groups <- length(unique(data$MoCA_group))
data$MoCA_group <- factor(data$MoCA_group, levels = c("normal", "low"))
contrasts(data$MoCA_group) <- contr.sum(n_groups)
# Preparation 3: Subject ID
data$subject_id <- factor(data$subject_id)
# Preparation 4: z-score continuous variables
data$PTA_z <- scale(data$PTA_dB)
# Check what contrasts look like
data$model
data$MoCA_group
# Check factor variable
data$subject_id
# Check z-scored continuous variables
data$PTA_z
# ----------------------------------------------------------------------
# Define fixed effects structure
# (I only include random intercepts in random effects structure)
max_model <- lmer(
score_r ~ 1 + MoCA_group * PTA_z * model +
(1 | subject_id),
data = data,
control = lmerControl(optimizer = "bobyqa")
)
red1_model <- lmer(
score_r ~ 1 + MoCA_group * PTA_z + model +
(1 | subject_id),
data = data,
control = lmerControl(optimizer = "bobyqa")
)
red2_model <- lmer(
score_r ~ 1 + MoCA_group * model +
(1 | subject_id),
data = data,
control = lmerControl(optimizer = "bobyqa")
)
anova(max_model, red1_model, red2_model)
final_model <- max_model
summary(final_model)
# ----------------------------------------------------------------------
# Model diagnostics
# Residuals vs Fitted
plot(fitted(final_model), residuals(final_model), main = "Residuals vs Fitted")
abline(h = 0, col = "red")
# QQ Plot of residuals
qqnorm(residuals(final_model))
qqline(residuals(final_model), col = "red")
# Histogram of residuals
hist(residuals(final_model), breaks = 30, main = "Histogram of Residuals")
# Extract random effects
ranef(final_model)
# Cook's Distance
cooksd <- cooks.distance(final_model)
plot(cooksd, main = "Cook's Distance", type = "h")
abline(h = 4 / (nrow(data) - length(fixef(final_model))), col = "red")
# Goodness-of-Fit
r.squaredGLMM(final_model)
AIC(final_model)
BIC(final_model)
# Multicollinearity
vif(lm(score_r ~ MoCA_group * PTA_z * model, data = data))
# ----------------------------------------------------------------------
# Post-hoc analysis
emm_interaction <- emmeans(final_model, ~ PTA_z * model)
pairs(emm_interaction)
# Plot interaction
emm_data <- as.data.frame(emm_interaction)
ggplot(emm_data, aes(x = model, y = emmean, color = as.factor(PTA_z))) +
geom_point(position = position_dodge(width = 0.5)) +
geom_errorbar(
aes(ymin = emmean - SE, ymax = emmean + SE),
width = 0.2,
position = position_dodge(width = 0.5)
) +
labs(title = "Interaction between PTA_z and Model on Scores",
x = "Model",
y = "Estimated Marginal Means",
color = "PTA_z") +
theme_minimal()
# ----------------------------------------------------------------------
# Draw inferences and create nice LaTeX tables
p_values <- summary(final_model)$coefficients[, "Pr(>|t|)"]
conf_intervals <- confint(
final_model,
parm = "beta_",
method = "Wald",
nsim = 5000,
seed = 2025
)
ci_tab <- as.data.frame(cbind(
estimate = fixef(final_model),
conf_intervals,
p_values
))
new_coeff_names <- c(
"Intercept",
"MoCA group (low)",
"PTA ($z$)",
"Model (Segment. word-level)",
"Model (Segment. phoneme-level)",
"Model (Linguistic word-level)",
"Model (Linguistic phoneme-level)",
"MoCA group (low) * PTA ($z$)",
"MoCA group (low) * Model (Segment. word-level)",
"MoCA group (low) * Model (Segment. phoneme-level)",
"MoCA group (low) * Model (Linguistic word-level)",
"MoCA group (low) * Model (Linguistic phoneme-level)",
"PTA ($z$) * Model (Segment. word-level)",
"PTA ($z$) * Model (Segmentation phoneme-level)",
"PTA ($z$) * Model (Linguistic word-level)",
"PTA ($z$) * Model (Linguistic phoneme-level)",
"MoCA group (low) * PTA ($z$) * Model (Segment. word-level)",
"MoCA group (low) * PTA ($z$) * Model (Segment. phoneme-level)",
"MoCA group (low) * PTA ($z$) * Model (Linguistic word-level)",
"MoCA group (low) * PTA ($z$) * Model (Linguistic phoneme-level)"
)
rownames(ci_tab) <- new_coeff_names
# Add significance stars
ci_tab$significance <- ifelse(
ci_tab$p_values < 0.001, "***",
ifelse(
ci_tab$p_values < 0.01, "**",
ifelse(
ci_tab$p_values < 0.05, "*",
""
)
)
)
# Apply formatting
ci_tab$estimate <- sapply(ci_tab$estimate, format_and_wrap)
ci_tab$`2.5 %` <- sapply(ci_tab$`2.5 %`, format_and_wrap)
ci_tab$`97.5 %` <- sapply(ci_tab$`97.5 %`, format_and_wrap)
ci_tab$p_values <- sapply(ci_tab$p_values, format_and_wrap)
ci_tab <- rownames_to_column(ci_tab, var = "Coefficient")
# Rename columns
colnames(ci_tab) <- c("Coefficient", "Estimate", "$LL$", "$UL$", "$p$", "")
# Create xtable object
xtable_ci <- xtable(ci_tab, caption = "Caption")
# Define alignment for columns
align(xtable_ci) <- c("l", "l", "r", "r", "r", "r", "l")
# Save to .tex file
writeLines(
print(
xtable_ci,
add.to.row = list(pos = list(-1),
command = c("\\hline & & \\multicolumn{2}{c}{95\\% CI} & & \\\\ \\cmidrule(r){3-4}\n")),
include.rownames = FALSE,
hline.after = c(0, nrow(ci_tab)),
sanitize.text.function = sanitize,
), paste(tables_dir, scores_table_file, sep = "/")
)
